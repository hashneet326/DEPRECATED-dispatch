'use strict';

const utils = require('./utils');

const slack = {};

/**
 * Encompasses all Slack alert functionality
 *
 * @param {object} sns - SNS message body from incoming/function.js
 * @param {string} destination - Slack alert destination, either a user or default channel
 * @param {object} client - Slack WebClient, created in incoming/function.js
 * @param {string} slackChannel - Fallback Slack channel in the event of error alerting to destination
 * @param {function} callback - returns err and status
 */
slack.alertToSlack = function(sns, destination, client, slackChannel, callback) {
  if (!sns.number) return callback(`Error - dispatch ${sns.requestId} message body missing GitHub issue number`);

  utils.encode({ github: sns.number }, (err, res) => {
    if (err) return callback(err);

    // add encode result to SNS message as callback_id for Slack API
    sns.callback_id = res;

    slack.formatMessage(sns, (err, message, prompt) => {
      if (err) {
        let status = message;
        return callback(err, status);
      }

      let slackFailureMessage = `Error - dispatch ${sns.requestId} failed to send message to ${destination}, see Slack and Lambda logs for details`;

      // send message
      slack.postAlert(destination, message, client, slackChannel, sns.requestId, (err, res) => {
        if (err) return callback(slackFailureMessage, res);

        let status = {
          alert: res.ok,
          destination: destination,
          message: res.message.text,
          url: sns.url
        };

        // send prompt
        if (prompt) {
          slack.postAlert(destination, prompt, client, slackChannel, sns.requestId, (err, res) => {
            if (err) return callback(slackFailureMessage, res);

            status.message = `${status.message}, Prompt: ${res.message.text}`;

            return callback(null, status);
          });
        } else {
          return callback(null, status);
        }
      });
    });
  });
};

/**
 * Formats SNS message contents for posting to Slack
 *
 * @param {object} sns - SNS message body
 * @param {function} callback - returns err, message, and prompt (if needed)
 */
slack.formatMessage = function(sns, callback) {
  try {
    let message = {
      text: sns.body.slack.message,
      attachments: [
        {
          fallback: 'Could not load GitHub issue.',
          callback_id: sns.callback_id,
          attachment_type: 'default'
        }
      ]
    };

    if (sns.url && sns.type != 'broadcast') message.attachments[0].text = sns.url;

    if (sns.body.slack.prompt) {
      let prompt = {
        text: sns.body.slack.prompt,
        attachments: [
          {
            fallback: 'You are unable to address this alert via Slack, refer to the GitHub issue.',
            callback_id: sns.callback_id,
            attachment_type: 'default',
            actions: [
              {
                name: 'yes',
                text: sns.body.slack.actions.yes,
                type: 'button',
                value: (sns.body.slack.actions.yes_response ? sns.body.slack.actions.yes_response : false)
              },
              {
                name: 'no',
                text: sns.body.slack.actions.no,
                type: 'button',
                value: (sns.body.slack.actions.no_response ? sns.body.slack.actions.no_response : false),
                style: 'danger'
              }
            ]
          }
        ]
      };


      return callback(null, message, prompt);
    } else {
      return callback(null, message, null);
    }
  } catch (err) {
    return callback(err, `dispatch ${sns.requestId} - SNS message parsing error`);
  }
};

/**
 * Posts an alert to Slack
 *
 * @param {string} destination - Slack alert destination, either a user or default channel
 * @param {object} message - message or prompt body generated by formatMessage
 * @param {object} client - Slack WebClient, created in incoming/function.js
 * @param {string} slackChannel - Fallback Slack channel in the event of error alerting to destination
 * @param {string} requestId - unique ID per dispatch alert
 * @param {function} callback - returns err and res
 */
slack.postAlert = function(destination, message, client, slackChannel, requestId, callback) {
  if (!message.text) return callback(`Error - dispatch ${requestId} missing Slack message body`);

  let options;

  if (destination.indexOf('@') > -1) {
    // destination is a user
    options = { 'as_user': true, attachments: message.attachments };
  }
  if (destination.indexOf('#') > -1) {
    // destination is a channel
    options = { attachments: message.attachments };
  }

  client.chat.postMessage(destination, message.text, options, (err, res) => {
    if (err) {
      console.log(`Error ${res.error} - dispatch ${requestId} failed to send message to Slack destination: ${destination}`);

      // log error to default SlackChannel for visibility
      let postFailure = {
        text: `Error sending message to \`${destination}\` for requestId ${requestId}`,
        attachments: [
          {
            title: 'Slack error message',
            text: JSON.stringify(res)
          }
        ]
      };

      client.chat.postMessage(slackChannel, postFailure.text, { attachments: postFailure.attachments }, (err, res) => {
        if (err) console.log(`Error ${res.error} - dispatch ${requestId} failed to send message to Slack channel ${slackChannel} for Slack destination failure ${destination}`);

        // return custom error to skip generating second error notification
        return callback('slackAlertRoutingError', res);
      });
    } else {
      return callback(null, res);
    }
  });
};

module.exports = slack;